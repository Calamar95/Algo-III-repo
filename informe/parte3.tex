\subsection{Idea general del problema}
El ejercicio nos propone diseñar un algoritmo para resolver el siguiente problema: dado un grupo de exploradoras, y el conjunto 
de amigas de cada una de ellas, organizar una ronda de manera tal que exista la menor distancia posible entre cada amistad, es 
decir, minimizar la suma de las distancias entre todos los pares de amigas. \\

La complejidad de la solución debe ser estrictamente menor que O($e^ea^2$), donde $e$ es la cantidad de exploradoras en cada grupo, y $a$ la cantidad de amistades. \\

Algunos ejemplos de posibles datos de entrada del problema son: \\

a bcde;b acde;c abde;d abc;e abc \\
a bcd;b ae;c ad;d ac;e b \\
a fb;b gc;d gc;f agh;e hd \\
x yz \\

Cada línea corresponde a un grupo de exploradoras; y se compone de una exploradora, seguida por una sucesion de amistades
separadas por ``;"$ $. Por ejemplo, en la primer línea, el grupo de exploradoras esta compuesto por ``a"$ $ cuyas amigas son [bcde],
``b"$ $ con [acde], ``c"$ $ con [abde] y por último ``d"$ $ y ``e"$ $ con  [abc]. Asumimos que las amistades son simétricas, es decir, si ``a"$ $ es
amiga de ``b"$ $, entonces ``b"$ $ es amiga de ``a"$ $. Por lo tanto, aunque ocurra que ``x"$ $ este en el conjunto de amigas de ``y"$ $, pero ``y"$ $ no este en el de ``x"$ $, debemos interpretarlo como que cada una esta en el grupo de amigas de la otra.  \\

Las salidas que corresponden a los ejemplos recien dados son las siguientes (mismo orden): \\
2 abdce \\
2 abecd \\
3 abgcdehf \\
1 xyz \\

La sucesión de caracteres representa la solución del problema, es decir, la ronda en la que exista la menor distancia posible entre cada amistad. El número que está delante, es la máxima distancia que hay entre dos amigas en la ronda solución. Si es que existe mas de una ronda óptima, se debe dar la que esté primera alfabéticamente. 

\subsection{Explicación y pseudocódigo}
Para resolver el problema diseñamos un algoritmo que consiste en, dado un grupo de exploradoras, generar todas las rondas 
posibles, e ir almacenando aquella que hasta el momento es la ``mejor"$ $ entre las ya calculadas (con ``mejor"$ $ nos referimos a aquella que minimiza la suma de las distancias entre amigas).\\

Para armar las permutaciones utilizamos la funcion $next$\_$permutation$, perteneciente a la librería standard de c++. Mediante 
esta funcion vamos generando todas las rondas posibles en orden alfabetico. Entonces, a medida que vamos armando las 
distintas rondas posibles, calculamos la suma de distancias y luego la comparamos con la suma de la que tenemos almacenada. Si 
la suma de la nueva ronda es menor entonces nos guardamos la nueva, pues es ``mejor"$ $ que la que teníamos. Caso contrario, 
pasamos a calcular la siguiente ronda, pues si la suma es mayor esa ronda no nos interesa, y si es igual tampoco, porque como
las rondas se van calculando en orden alfabetico, entonces la que ya tenemos guardada va a estar primera teniendo en cuenta
dicho orden. \\

El algoritmo termina una vez que se hayan calculado todas las rondas posibles. La última ronda que quedó guardada va a ser nuestra solución. Por otra parte, la máxima distancia entre dos amigas de la ronda, se calcula en simultáneo con la suma de las distancias, y siempre la almacenamos junto con la ``mejor"$ $ ronda durante todo el algoritmo. \\

Para entender mejor la idea dejamos el algoritmo en pseudocódigo:\\   

--------------------------------------------------------------------------------------------------------------\\
tupla$<$int, vector$<$char$>$ $>$ mejorRonda(vector$<$char$>$ exploradoras, vector$<$vector$<$char$>>$ amigas)\{ \\
$~~~~~~~~$crear tupla$<$int, int$>$ sumaMinima\Ode{tamaño de a} \\
$~~~~~~~~$crear vector$<$char$>$ rondaOptima \Ode{tamaño de a} \\
$~~~~~~~~$ordenar alfabeticamente exploradoras \Ode{1} \\
$~~~~~~~~$rondaOptima $\leftarrow$ posibles\Ode{1} \\
$~~~~~~~~$sumaMinima $\leftarrow$ calcularSuma(rondaOptima, exp, amigas) \Ode{1} \\
$~~~~~~~~$maxDist $\leftarrow$ maximaDistancia(rondaOptima, exp, amigas)\Ode{1} \\
$~~~~~~~~$\textbf{mientras} (hay nueva permutacion de posibles) \{ \Ode{1} \\
$~~~~~~~~~~~~$crear int nuevaSuma $\leftarrow$ calcularSuma(posibles, exp, amigas) \Ode{1} \\
$~~~~~~~~~~~~$\textbf{si} calcularSuma(posibles, exp, amigas) \Ode{1} \\
\\

El calculo de la suma de las distancias lo hacemos mediante un algoritmo iterativo que, lo que hace, es recorrer el vector
(que representa a la ronda), y para cada exploradora calcula cuál es la ditancia entre ella y cada una de sus amigas (mediante 
otro ciclo interno). Se repite el procedimiento hasta que el vector se recorre completamente, y así obtenemos la suma de las distancias.  


\subsection{Deducción de la cota de complejidad temporal}

Para la resolución de este ejercicio construimos la clase ronda en c++. La ronda se representa, en la parte privada de la clase,
mediante un vector$<$char$>$, donde los char representan a las exploradoras y cómo están ubicadas en la ronda. También posee un 
diccionario(utilizamos $<$map$>$ de la STL de c++), donde están asociadas las exploradoras a sus respectivos grupos de amigas. \\
La clase cuenta con el constructor por defecto (ronda vacia) y otro constructor que recibe como parámetros un vector$<$char$>$ y un
vector$<$vector$<$char$>>$; donde el primero representa el conjunto de exploradoras, y el segundo las amigas de cada una (asociadas
por el orden de los vectores). Como el enunciado del ejercicio permite que mismos grupos de exploradoras sean escritos de distintas 
formas (por ejemplo a bc;b ac;c ab también se puede escribir como a b;b c;c ab), construimos la función $completarAmigas$ que se 
encarga de verficar que ninguna amistad esté ausente en la lista de una exploradora, y que estén presentes la totalidad de las 
exploradoras, cada una con su grupo de amigas. Esta función la utilizamos en el constructor, de manera que se almacene en la parte 
privada toda la información completa. \\
La complejidad de $completarAmigas$ es O($e^3$) en el peor caso; y el algoritmo consiste en los siguientes pasos (recibe los mismos 
parámetros de entrada que el constructor): \\
\begin{itemize}
\item Recorrer el vector$<$char$>$ que contiene i exploradoras. \\
Costo: O($e$) pues como maximo  e = i. 
\item Por cada una de las exploradoras recorrer su grupo de amigas. \\
Costo: O($e$) pues como maximo son e - 1 amigas.
\item Por cada amiga, verificar si está presente en el vector de exploradoras y en caso positivo (si no está presente se agrega, que 
toma O(1)), verificar si la exploradora i está presente en el grupo de dicha amiga(si no está presente se agrega, que 
toma O(1)).  \\
Costo: O($e$) pues son dos busquedas lineales con costo O($e$) en el peor caso cada una.
\end{itemize}
Finalmente la ecuación de la complejidad del algoritmo es O($e$) x O($e$) x O($e$) = O($e^3$). \\
Otra operación pública de nuestra clase es $sumaDistancias$, que devuelve una dupla de enteros, donde la primer componente 
representa la suma de las distancias entre las exploradoras que son amigas, y la segunda, la mayor distancia entre dos amigas en 
la ronda. A continuación analizamos la complejidad de $sumaDistancias$: 
\begin{itemize}
\item Recorrer el vector$<$char$>$ que contiene a las exploradoras. \\
Costo: O($e$) pues siempre las rondas tienen e exploradoras.
\item Por cada exploradora buscar su grupo de amigas en el diccionario y copiarlo a un vector auxiliar. \\
Costo: O($e$) pues buscar en el diccionario es O(log($e$))(extraido de cppreference.com) y copiarlo es O($e$).
\item Por cada amiga buscamos su posición en la ronda y calculamos la distancia entre ella y la exploradora a la que le corresponde el vector de amigas que estamos recorriendo. \\
Costo: O($e$) pues es buscar su posicion linealmente sobre e elementos, y el cálculo es O(1).
\end{itemize}
Finalmente la ecuación de la complejidad del algoritmo es O($e$) x O($e$) x O($e$) = O($e^3$). \\
\\
Otras operaciones que implementamos en la clase Ronda son: 
\begin{itemize}
\item $cambiarOrden$; que cambia las posiciones de las exploradoras en la ronda (lo hace en orden alfabético). Utilizamos la función 
$next$\_$permutation$ de la STL de c++, por lo que la complejidad es O($e$) en el peor caso(extraido de cppreference.com). 
\item $ordenAlfabetico$; que ordena la ronda alfabéticamente. Para ello usamos la función $sort$ de la STL, con complejidad
O($e$ log($e$)) (extraido de cppreference.com).
\end{itemize}

Ahora analicemos la complejidad de la principal operación del ejercicio

\subsection{Demostración formal}
El procedimiento que utilizamos resuelve el problema porque, dada una ronda, al combinar las exploradoras de todas las maneras 
posibles

\subsection{Experimentaciones}